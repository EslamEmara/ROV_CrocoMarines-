import time
import socket
import threading
import pygame
from pygame.locals import*
import sys
import os
from os import path
from comlib import *
import numpy as np
import serial

import PyQt5
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.uic import loadUiType
from PyQt5 import QtCore, QtGui
from PyQt5.QtCore import QCoreApplication


FORM_CLASS, _ = loadUiType(path.join(path.dirname(__file__), "client1.ui")) #used to make any changed in .ui code work on here

class MainApp(QMainWindow , FORM_CLASS):        #defining the class MainApp and make it inherit from QMainWindow which is generated by .ui file
    def __init__(self, msg, parent=None):
        super(MainApp , self).__init__(parent)
        QMainWindow.__init__(self)

        #self.FORMAT = 'utf-8'   #variable instead of typing utf-8
        

        pygame.init()   #initializing pygame library
        self.joystick_count = pygame.joystick.get_count()           #counts the number of controllers
        print("Number of joysticks:",format(self.joystick_count) )  #prints number of controllers

        for i in range(self.joystick_count):                #loops on controllers
            self.joystick = pygame.joystick.Joystick(i)     #setting variable name joystick instead of typing all that
            self.joystick.init()                            #initializing controller with each loop
            print("initialized joystick",i)                 #prints indication of initialization

        self.speed = 0              #defining constant speed 
        self.msg = msg              #making message self.msg to use it in all functions of class
        self.connected = False      #flag for the connection, True if the socket is connected to server
        self.micro_active = False   #flag indicates if the micro ROV is activated or not
        self.controller0 = 0        #variable to change controller id if code on another device doesnt read the 2 controllers in the same order as this one
        self.controller1 = 1        #same as the variable before it for the second controller
        self.time_started = False   #flag indicates if the timer started or not
        
        self.pitch = 0.0
        self.roll = 0.0
        self.rotate = 0.0
        self.temp = 0.0
        self.hight = 0.0

        #thread_02 = threading.Thread(target = self.receive, args=())       #threading on the receive function
        #thread_02.start()   #starts the thread

        self.setupUi(self)      #sets up the ui
        self.Handel_UI()        #calling function to work when the class is initialized
        self.Handel_Buttons()   #calling function to work when the class is initialized to handle buttons

    def closeEvent(self, event):    #event when user clicks on the x of the gui window
        reply = QMessageBox.question(self, 'Close Confirmation', 'Are you sure you want to close?',
                QMessageBox.Yes | QMessageBox.No, QMessageBox.No)   #shows a question box asking if he wants to close window and has yes or no

        if reply == QMessageBox.Yes:    #if yes is clicked then accept the event 
            event.accept()
            if self.connected:  #checks if the connected flag is true and if it is then send disconecting message
                self.station.send("[DISCONNECT] Client Disconnected.")
                self.station.shutdown(socket.SHUT_RDWR)      #shuts down the socket
                self.station.close()        #closes the socket
        else:       #if no is clicked then ignore it
            event.ignore()

    def Handel_UI(self):    #function that handels the ui of the gui
        self.setWindowTitle('Croco GUI')    #sets window name
        self.setFixedSize(751, 655)         #sets size fixed so it cant be changed
        self.lineEdit_2.setMaxLength(5)     #sets the max length of port line edit to 5 numbers
        self.lineEdit.setMaxLength(13)      #sets the max length of ip line edit to 13 numbers
        self.lineEdit_2.setValidator(QIntValidator())   #only allows int type of input in port line edit

    def Handel_Buttons(self):       #func that handels the buttons in the gui
        self.pushButton.clicked.connect(self.conn_clicked)         #button connect in gui is signal for start() func
        self.pushButton_2.clicked.connect(self.disconn_clicked)  #button disconnect in gui is signal for closeEvent() func which is same as pressing x in gui window
        

    # def Disconnect(self):
    #     if self.connected:  #checks on flag if socket is connected 
    #         self.connected = False
    #         print("Disconnected!")
    #         self.label_14.setText("Disconnected")
    #         self.station.shutdown(socket.SHUT_RDWR)
    #         #self.station.close()
    #         #self.close()    #calls the function closeEvent() using its special method .close
    #     else:
    #         print("cant disconnect")
    #         # pass            #if not connected then do nothing
        
    # def start(self):    #called when connect button is pressed
    #     try:       #try the connection
    #         PORT = int(self.lineEdit_2.text())  #takes port from line edit in gui
    #         IP = self.lineEdit.text()           #takes ip from line edit in gui
    #         self.station.connect((IP, PORT))     #connect to socket
    #         print(f"[CONNECTION] successfully connected to {(IP, PORT)} \n")       #print indicating connecting 
    #         self.connected = True         #sets flag connected to true
    #         self.label_14.setText("Connected")
    #     except:     #if cant connect then dont do anything and dont give an error
    #         print("Couldn't connect to server")
            #pass
        #if self.connected == True:      #when flag connected is true 
            #self.label_14.setText("Connected")  #sets text of lable to connected to show that connecting is made on gui
            #self.lineEdit_2.setReadOnly(True)   #sets line edit of port to read only so user cant change text 
            #self.lineEdit.setReadOnly(True)     #sets line edit of ip to read only so user cant change text 

    def count_up(self):     #function of the timer 
        
        seconds = 900       #sets timer to 15 mins which are the tasks time allowed
        self.time_started = True    #sets flag when time is started
        for j in range(1,seconds+1):    #loops on numbers from 1 to 900
            if self.connected == True:
                mins = j/60     #makes variable mins equal to seconds /60
                j = j%60        #takes the int value of the sec only
                mins = int(mins%60)   #takes the int value of the mins only
                self.label_50.setText(f"{mins}:{j}")    #sets text of label showing time to the value
                time.sleep(1)      #delay 1 sec so timer changes every 1 sec
                self.label_50.setText("Time's up!")     #when 900 secs is done set label to time's done
            else:
                self.label_50.setText("0:0")
        
        
            
###################################################################################################

    def send_msg(self):
        for event in pygame.event.get():    #loops on events of pygame library

            if event.type == JOYBUTTONDOWN:     #if event is button down on controller
                if event.button == 0 and event.joy == self.controller0:    #move servo gripper to neutral position when triangle is pressed on controller 0
                    self.station.send("sgrip n")
                   

                if event.button == 1 and event.joy == self.controller0:    #move servo gripper to right position 90 degree from neutral when circle is pressed on controller 0
                    self.station.send("sgrip r")
                   

                if event.button == 3 and event.joy == self.controller0:    #move servo gripper to left position 90 degree from neutral when square is pressed on controller 0
                    self.station.send("sgrip l")
                   

                if event.button == 4 and event.joy == self.controller0:    #camera up with L1 when pressed on controller 0
                    self.station.send("cam up")
                   

                if event.button == 5 and event.joy == self.controller0:    #speed up with R1 when pressed on controller 0
                    self.speed = self.speed +30                            #inc speed by 30
                    if self.speed >= 150 :                                 #max speed can be increased is 150 because of power
                        self.speed = 150
                    self.msg = "speed " + str(self.speed)                  
                    self.station.send(self.msg)         #send speed value 
                    self.label_4.setText(str(self.speed+90))               #shows the speed value + 90 which are default speed on gui
                   

                if event.button == 6 and event.joy == self.controller0:     #camera down with L2 when pressed on controller 0
                    self.station.send("cam down") 
                          
                    
                if event.button == 7 and event.joy == self.controller0:     #speed down with R2 when pressed  on controller 0        
                    self.speed = self.speed - 30                            #dec speed by 30
                    if self.speed <= 0 :
                        self.speed = 0
                    self.msg = "speed " + str(self.speed)
                    self.station.send(self.msg)         #send speed value 
                    self.label_4.setText(str(self.speed+90))               #shows the speed value + 90 which are default speed on gui
                   

                if event.button == 8 and event.joy == self.controller0:        #starts timer when select button on controller 0 is pressed 
                    if self.connected == True and self.time_started == False:  #sets flags values
                        self.time_started = True
                        thread_01 = threading.Thread(target = self.count_up, args=())   #starts threading on counter loop so it works with program smoothly
                        thread_01.start()
                    
                if event.button == 9 and event.joy == self.controller0:        #connects socket when start button on controller 0 is pressed 
                    if not self.connected:
                        self.com_init()

                if event.button == 10 and event.joy == self.controller0:         #closes the servo dc gripper of ROV when right analog button is pressed on controller 0
                    self.station.send("grip close")
                    self.label_27.setText("Closing")
                   
                
                if event.button == 11 and event.joy == self.controller0:        #opens the servo dc gripper of ROV when right analog button is pressed on controller 0
                    self.station.send("grip open")
                    self.label_27.setText("Opening")
                   

                #if event.button == 9 and event.joy == self.controller1 and self.connected == True:     #Activates micro ROV when start is pressed on controller 1 if the socket is connected      
                if event.button == 0 and event.joy == self.controller1 and self.connected == True:      #testing on button triangle as start is not working on my controller
                    self.micro_active = True        #sets flag value
                    self.label_24.setText("Connected")

                if event.button == 8 and event.joy == self.controller1 and self.connected == True:    #Deactivates micro ROV when select is pressed on controller 1
                    self.micro_active = False   #sets flag value
                    self.label_24.setText("Disconnected")

                if event.button == 10 and event.joy == self.controller1 and (self.micro_active == True):    #closes the dc gripper of micoro ROV when left analog button is pressed on controller 1
                    self.station.send("micro close")
                    self.label_29.setText("Closing")
                   

                if event.button == 11 and event.joy == self.controller1 and (self.micro_active == True):    #opens the dc gripper of micoro ROV when right analog button is pressed on controller 1
                    self.station.send("micro open")
                    self.label_29.setText("Opening")
                   

#############################################################################################################

            if event.type == JOYBUTTONUP:
                if event.button == 4 and event.joy == self.controller0:         #camera stops when L1 is released
                    self.station.send("cam stop")
                   

                if event.button == 6 and event.joy == self.controller0:           #camera stops when L2 is released
                    self.station.send("cam stop") 
                    

                if event.button == 10 and event.joy == self.controller1 and (self.micro_active == True):    #stops the dc gripper of micoro ROV when left analog button is released on controller 1
                    self.station.send("micro hold")
                    self.label_29.setText("Static")
                   

                if event.button == 11 and event.joy == self.controller1 and (self.micro_active == True):    #stops the dc gripper of micoro ROV when right analog button is released on controller 1
                    self.station.send("micro hold")
                    self.label_29.setText("Static")
                   

                if event.button == 10 and event.joy == self.controller0:         #stops the servo dc gripper of ROV when right analog button is released on controller 0
                    self.station.send("grip hold")
                    self.label_27.setText("Static")
                   
                
                if event.button == 11 and event.joy == self.controller0:        #stops the servo dc gripper of ROV when right analog button is released on controller 0
                    self.station.send("grip hold")
                    self.label_27.setText("Static")
                   
                    
#############################################################################################################

            if event.type == JOYHATMOTION:
                if event.value == (1,0) and event.joy == self.controller0:             #slide right when right button on controller 0 is pressed
                    self.station.send("move right")
                    self.label_19.setText("Sliding right")
                   

                elif event.value == (-1,0) and event.joy == self.controller0:            #slide left when left button on controller 0 is pressed
                    self.station.send("move left")
                    self.label_19.setText("Sliding left")
                   

                elif event.value == (0,-1) and event.joy == self.controller0:            #move down when down button on controller 0 is pressed
                    self.station.send("move down")
                    self.label_19.setText("Descending")
                   

                elif event.value == (0,1) and event.joy == self.controller0:             #move up when up button on controller 0 is pressed
                    self.station.send("move up")
                    self.label_19.setText("Ascending")
                   

                elif event.value == (0,0) and event.joy == self.controller0:           #stops motion when you remove your hand from any arrow button
                    self.station.send("move stop")
                    self.label_19.setText("Static")
                   

    ###################################################################################################

            if event.type == JOYAXISMOTION:          
                if pygame.joystick.Joystick(self.controller0).get_axis(0) >= 0.98 :        #rotate right when left analog of controller 0 moves right
                    self.station.send("move yawcw")
                    self.label_19.setText("Rotating right")
                   
                
                elif pygame.joystick.Joystick(self.controller0).get_axis(0) <= -1 :       #rotate left when left analog of controller 0 moves left
                    self.station.send("move yawccw")
                    self.label_19.setText("Rotating left")
                   

                elif pygame.joystick.Joystick(self.controller0).get_axis(1) >= 0.98 :        #move backward when left analog of controller 0 moves back
                    self.station.send("move backward")
                    self.label_19.setText("Moving backward")
                   

                elif pygame.joystick.Joystick(self.controller0).get_axis(1) <= -1 :       #move forward when left analog of controller 0 moves forward
                    self.station.send("move forward")
                    self.label_19.setText("Moving forward")
                   
                
                elif pygame.joystick.Joystick(self.controller0).get_axis(3) >= 0.98 :        #roll right when right analog of controller 0 moves right
                    self.station.send("move rolltoright")
                    self.label_19.setText("Rolling right")
                   
                
                elif pygame.joystick.Joystick(self.controller0).get_axis(3) <= -1 :       #roll left when right analog of controller 0 moves left
                    self.station.send("move rolltoleft")
                    self.label_19.setText("Rolling left")
                   

                elif pygame.joystick.Joystick(self.controller0).get_axis(2) >= 0.98 :        #pitch up when right analog of controller 0 moves back
                    self.station.send("move pitchup")
                    self.label_19.setText("Pitching up")
                   

                elif pygame.joystick.Joystick(self.controller0).get_axis(2) <= -1 :       #pitch down when right analog of controller 0 moves forward
                    self.station.send("move pitchdown")
                    self.label_19.setText("Pitching down")
                   

                elif ((pygame.joystick.Joystick(self.controller1).get_axis(0) >= -0.1) and (pygame.joystick.Joystick(self.controller1).get_axis(0) <= 0.1) and
                    (pygame.joystick.Joystick(self.controller1).get_axis(1) >= -0.1) and (pygame.joystick.Joystick(self.controller1).get_axis(1) <= 0.1)   and
                    (pygame.joystick.Joystick(self.controller1).get_axis(3) >= -0.1) and (pygame.joystick.Joystick(self.controller1).get_axis(3) <= 0.1)   and 
                    (pygame.joystick.Joystick(self.controller1).get_axis(2) >= -0.1) and (pygame.joystick.Joystick(self.controller1).get_axis(2) <= 0.1)   and
                    (pygame.joystick.Joystick(self.controller0).get_axis(0) >= -0.1) and (pygame.joystick.Joystick(self.controller0).get_axis(0) <= 0.1)   and 
                    (pygame.joystick.Joystick(self.controller0).get_axis(1) >= -0.1) and (pygame.joystick.Joystick(self.controller0).get_axis(1) <= 0.1)   and
                    (pygame.joystick.Joystick(self.controller0).get_axis(3) >= -0.1) and (pygame.joystick.Joystick(self.controller0).get_axis(3) <= 0.1)   and 
                    (pygame.joystick.Joystick(self.controller0).get_axis(2) >= -0.1) and (pygame.joystick.Joystick(self.controller0).get_axis(2) <= 0.1)) :     
                    self.station.send("move stop")     #stops ROV motion if both analogs are not at motion positions
                    self.label_19.setText("Static")
                   

###################################################################################################

            if (event.type == JOYAXISMOTION) and (self.micro_active == True):
                if pygame.joystick.Joystick(self.controller1).get_axis(1) >= 0.98 :        #move micro ROV backward when left analog of controller 1 moves back
                    self.station.send("micro backward")
                    self.label_21.setText("Backward")
                   

                elif pygame.joystick.Joystick(self.controller1).get_axis(1) <= -0.99 :       #move micro ROV forward when left analog of controller 1 moves forward
                    self.station.send("micro forward")
                    self.label_21.setText("Forward")
                   

                elif ((pygame.joystick.Joystick(self.controller1).get_axis(0) >= -0.1) and (pygame.joystick.Joystick(self.controller1).get_axis(0) <= 0.1) and
                    (pygame.joystick.Joystick(self.controller1).get_axis(1) >= -0.1) and (pygame.joystick.Joystick(self.controller1).get_axis(1) <= 0.1)   and
                    (pygame.joystick.Joystick(self.controller1).get_axis(3) >= -0.1) and (pygame.joystick.Joystick(self.controller1).get_axis(3) <= 0.1)   and 
                    (pygame.joystick.Joystick(self.controller1).get_axis(2) >= -0.1) and (pygame.joystick.Joystick(self.controller1).get_axis(2) <= 0.1)   and
                    (pygame.joystick.Joystick(self.controller0).get_axis(0) >= -0.1) and (pygame.joystick.Joystick(self.controller0).get_axis(0) <= 0.1)   and 
                    (pygame.joystick.Joystick(self.controller0).get_axis(1) >= -0.1) and (pygame.joystick.Joystick(self.controller0).get_axis(1) <= 0.1)   and
                    (pygame.joystick.Joystick(self.controller0).get_axis(3) >= -0.1) and (pygame.joystick.Joystick(self.controller0).get_axis(3) <= 0.1)   and 
                    (pygame.joystick.Joystick(self.controller0).get_axis(2) >= -0.1) and (pygame.joystick.Joystick(self.controller0).get_axis(2) <= 0.1)) :
                    self.station.send("micro stop")   #stops micro ROV motion if both analogs are not at motion positions
                    self.label_21.setText("Static")
                   

########################################################################################################################################################
########################################################################################################################################################
                                            ########    Communication functions     #######



    def receive_callback(self, received):
        while received == 'wrong frame':
            self.data_encode()
        try:
            self.pitch, self.roll, self.rotate, self.temp, self.hight = received.split(',',5)
            self.label_5.setText(self.rotate)
            self.label_6.setText(self.hight)
            self.label_7.setText(self.temp)
            self.label_8.setText(self.roll)
            self.label_9.setText(self.pitch)
        except:
            print('received: ',received)
            print("Couldn't Parse on IMU Data")
        
        # self.pitch = float(self.pitch)
        # self.roll = float(self.roll)
        # self.rotate = float(self.rotate)
        # self.temp = float(self.temp)
        # self.hight = float(self.hight)
        #print(self.pitch,',',self.roll,',',self.rotate,',',self.temp,',',self.hight)
        
        


    def com_init(self):
        IP = self.lineEdit.text()
        Port = int(self.lineEdit_2.text())   

        self.station = Client()
        self.station.on_receive(self.receive_callback)
        self.station.start(IP, Port)

        self.connected = True
        self.label_14.setText("Connected")
        print(f"[CONNECTION] successfully connected to {(IP, Port)} \n")       #print indicating connecting 
        self.station.send("connected from com_init")

    def conn_clicked(self):
        if not self.connected:
            self.com_init()
            #self.Joysticks_init()


    def disconn_clicked(self):
        if self.connected:
            self.station.send("stop_server")
            self.station.disconnect()

            self.connected = False
            print('disconnected')
            self.reset()

    def reset(self):
        self.label_14.setText("Disconnected")   #connection status
        self.label_24.setText("Disconnected")   #micro ROV status
        self.label_19.setText("Static")     #ROV current motion
        self.label_21.setText("Static")     #micro ROV current motion
        self.label_50.setText("0:0")    #reset timer
        self.time_started = False

        

###################################################################################################

    # def receive(self):
    #     while True:
    #         if self.connected:  #if flag of connection is true receive message
    #             self.msg = (self.station.recv(2048)).decode('utf-8')
    #             print(self.msg)     #print message

    #             if "angle" in self.msg:             #checks on the message if it is the message the imu will send "angle pitch roll rotate temp hight"
    #                 angle = self.msg.split()        #splits the message with space
    #                 self.label_9.setText(angle[1])  #puts the values on the labels in gui
    #                 self.label_8.setText(angle[2])
    #                 self.label_5.setText(angle[3])
    #                 self.label_7.setText(angle[4])
    #                 self.label_6.setText(angle[5])

###################################################################################################

if __name__ == "__main__":          #main loop
    app = QApplication(sys.argv)    #object of class QApplication
    window = MainApp("")  #object of class MainApp
    window.show()       #shows the window

    while True:
        try:        #try function send_msg, here i put send in the main loop instead of a third thread 
            window.send_msg()
        except:
            pass
    sys.exit(app.exec_())

###################################################################################################